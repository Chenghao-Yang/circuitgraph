<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.3" />
<title>circuitgraph.transform API documentation</title>
<meta name="description" content="Functions for transforming circuits" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>circuitgraph.transform</code></h1>
</header>
<section id="section-intro">
<p>Functions for transforming circuits</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Functions for transforming circuits&#34;&#34;&#34;
# TODO: this file name could change

import math
import code
from subprocess import PIPE, Popen
from tempfile import NamedTemporaryFile
from random import sample
import os

import networkx as nx

from circuitgraph import Circuit
from circuitgraph.io import verilog_to_circuit, circuit_to_verilog


def syn(c, engine=&#39;Genus&#39;, printOutput=False):
    &#34;&#34;&#34;
    Synthesizes the circuit using Genus.

    Parameters
    ----------
    c : Circuit
            Circuit to synthesize.
    engine : string
            Synthesis tool to use (&#39;Genus&#39; or &#39;Yosys&#39;)
    printOutput : bool
            Option to print synthesis log

    Returns
    -------
    Circuit
            Synthesized circuit.
    &#34;&#34;&#34;
    verilog = circuit_to_verilog(c)

    # probably should write output to the tmp file
    with NamedTemporaryFile() as tmp:
        if engine == &#39;Genus&#39;:
            cmd = [&#39;genus&#39;, &#39;-no_gui&#39;, &#39;-execute&#39;,
                   &#39;set_db / .library &#39;
                   f&#34;{os.environ[&#39;CIRCUITGRAPH_GENUS_LIBRARY_PATH&#39;]};\n&#34;
                   f&#39;read_hdl -sv {tmp.name};\n&#39;
                   &#39;elaborate;\n&#39;
                   &#39;set_db syn_generic_effort high;\n&#39;
                   &#39;syn_generic;\n&#39;
                   &#39;syn_map;\n&#39;
                   &#39;syn_opt;\n&#39;
                   &#39;write_hdl -generic;\n&#39;
                   &#39;exit;&#39;]
        else:
            print(&#39;not implemented&#39;)
        tmp.write(bytes(verilog, &#39;ascii&#39;))
        tmp.flush()

        process = Popen(cmd, stdout=PIPE, stderr=PIPE,
                        universal_newlines=True)
        output = &#39;&#39;
        while True:
            line = process.stdout.readline()
            if line == &#39;&#39; and process.poll() is not None:
                break
            if line:
                if printOutput:
                    print(line.strip())
                output += line

    return verilog_to_circuit(output, c.name)


def ternary(c):
    &#34;&#34;&#34;
    Encodes the circuit with ternary values

    Parameters
    ----------
    c : Circuit
            Circuit to encode.

    Returns
    -------
    Circuit
            Encoded circuit.

    &#34;&#34;&#34;
    t = c.copy()

    # add dual nodes
    for n in c:
        if c.type(n) in [&#39;and&#39;, &#39;nand&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;and&#39;, output=c.nodes[n][&#39;output&#39;])
            t.add_node(f&#39;{n}_x_in_fi&#39;, gate=&#39;or&#39;, output=False)
            t.add_node(f&#39;{n}_0_not_in_fi&#39;, gate=&#39;nor&#39;, output=False)
            t.add_edges_from([(f&#39;{n}_x_in_fi&#39;, f&#39;{n}_x&#39;),
                              (f&#39;{n}_0_not_in_fi&#39;, f&#39;{n}_x&#39;)])
            t.add_edges_from((f&#39;{p}_x&#39;, f&#39;{n}_x_in_fi&#39;)
                             for p in c.predecessors(n))
            for p in c.predecessors(n):
                t.add_node(f&#39;{p}_is_0&#39;, gate=&#39;nor&#39;, output=False)
                t.add_edge(f&#39;{p}_is_0&#39;, f&#39;{n}_0_not_in_fi&#39;)
                t.add_edge(f&#39;{p}_x&#39;, f&#39;{p}_is_0&#39;)
                t.add_edge(p, f&#39;{p}_is_0&#39;)

        elif c.type(n) in [&#39;or&#39;, &#39;nor&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;and&#39;, output=c.nodes[n][&#39;output&#39;])
            t.add_node(f&#39;{n}_x_in_fi&#39;, gate=&#39;or&#39;, output=False)
            t.add_node(f&#39;{n}_1_not_in_fi&#39;, gate=&#39;nor&#39;, output=False)
            t.add_edges_from([(f&#39;{n}_x_in_fi&#39;, f&#39;{n}_x&#39;),
                              (f&#39;{n}_1_not_in_fi&#39;, f&#39;{n}_x&#39;)])
            t.add_edges_from((f&#39;{p}_x&#39;, f&#39;{n}_x_in_fi&#39;)
                             for p in c.predecessors(n))
            for p in c.predecessors(n):
                t.add_node(f&#39;{p}_is_1&#39;, gate=&#39;and&#39;, output=False)
                t.add_edge(f&#39;{p}_is_1&#39;, f&#39;{n}_1_not_in_fi&#39;)
                t.add_node(f&#39;{p}_not_x&#39;, gate=&#39;not&#39;, output=False)
                t.add_edge(f&#39;{p}_x&#39;, f&#39;{p}_not_x&#39;)
                t.add_edge(f&#39;{p}_not_x&#39;, f&#39;{p}_is_1&#39;)
                t.add_edge(p, f&#39;{p}_is_1&#39;)

        elif c.type(n) in [&#39;buf&#39;, &#39;not&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;buf&#39;, output=c.nodes[n][&#39;output&#39;])
            p = list(c.predecessors(n))[0]
            t.add_edge(f&#39;{p}_x&#39;, f&#39;{n}_x&#39;)

        elif c.type(n) in [&#39;xor&#39;, &#39;xnor&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;or&#39;, output=c.nodes[n][&#39;output&#39;])
            t.add_edges_from((f&#39;{p}_x&#39;, f&#39;{n}_x&#39;) for p in c.predecessors(n))

        elif c.type(n) in [&#39;0&#39;, &#39;1&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;0&#39;, output=c.nodes[n][&#39;output&#39;])

        elif c.type(n) in [&#39;input&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;input&#39;, output=c.nodes[n][&#39;output&#39;])

        elif c.type(n) in [&#39;dff&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;dff&#39;,
                       output=c.nodes[n][&#39;output&#39;], clk=c.nodes[n][&#39;clk&#39;])
            p = list(c.predecessors(n))[0]
            t.add_edge(f&#39;{p}_x&#39;, f&#39;{n}_x&#39;)

        elif c.type(n) in [&#39;lat&#39;]:
            t.add_node(
                f&#39;{n}_x&#39;, gate=&#39;lat&#39;, output=c.nodes[n][&#39;output&#39;],
                clk=c.nodes[n][&#39;clk&#39;], rst=c.nodes[n][&#39;rst&#39;])
            p = list(c.predecessors(n))[0]
            t.add_edge(f&#39;{p}_x&#39;, f&#39;{n}_x&#39;)

        else:
            print(f&#34;unknown gate type: {c.nodes[n][&#39;type&#39;]}&#34;)
            code.interact(local=dict(globals(), **locals()))

    for n in t:
        if &#39;type&#39; not in t.nodes[n]:
            print(f&#34;empty gate type: {n}&#34;)
            code.interact(local=dict(globals(), **locals()))

    return t


def miter(c0, c1=None, startpoints=None, endpoints=None):
    &#34;&#34;&#34;
    Creates a miter circuit

    Parameters
    ----------
    c0 : Circuit
            First circuit.
    c1 : Circuit
            Optional second circuit, if None c0 is mitered with itself.
    startpoints : iterable of str
            Nodes to be tied together, must exist in both circuits.
    endpoints : iterable of str
            Nodes to be compared, must exist in both circuits.

    Returns
    -------
    Circuit
            Miter circuit.

    &#34;&#34;&#34;
    if not c1:
        c1 = c0
    if not startpoints:
        startpoints = c0.startpoints() &amp; c1.startpoints()
    if not endpoints:
        endpoints = c0.endpoints() &amp; c1.endpoints()

    # create miter, relabel to avoid overlap except for common startpoints
    m = c0.relabel({n: f&#39;c0_{n}&#39; for n in c0.nodes()-startpoints})
    m.extend(c1.relabel({n: f&#39;c1_{n}&#39; for n in c1.nodes()-startpoints}))

    # compare outputs
    m.add(&#39;sat&#39;, &#39;or&#39;)
    for o in endpoints:
        m.add(f&#39;miter_{o}&#39;, &#39;xor&#39;, fanin=[
              f&#39;c0_{o}&#39;, f&#39;c1_{o}&#39;], fanout=[&#39;sat&#39;])

    return m


def comb(c):
    &#34;&#34;&#34;
    Creates combinational version of the circuit.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to make combinational.

    Returns
    -------
    Circuit
            Combinational circuit.

    &#34;&#34;&#34;
    c_comb = c.copy()
    lat_model = gen_lat_model()
    ff_model = gen_ff_model()

    for lat in c.lats():
        relabeled_model = nx.relabel_nodes(
            lat_model, {n: f&#39;{lat}_{n}&#39; for n in lat_model})
        c_comb.extend(relabeled_model)
        c_comb.add_edges_from((f&#39;{lat}_q&#39;, s) for s in c_comb.successors(lat))
        c_comb.add_edges_from((p, f&#39;{lat}_d&#39;)
                              for p in c_comb.predecessors(lat))
        c_comb.add_edge(c.nodes[lat][&#39;clk&#39;], f&#39;{lat}_clk&#39;)
        c_comb.add_edge(c.nodes[lat][&#39;rst&#39;], f&#39;{lat}_rst&#39;)
        c_comb.remove_node(lat)

    for ff in c.ffs():
        relabeled_model = nx.relabel_nodes(
            ff_model, {n: f&#39;{ff}_{n}&#39; for n in ff_model})
        c_comb.extend(relabeled_model)
        c_comb.add_edges_from((f&#39;{ff}_q&#39;, s) for s in c_comb.successors(ff))
        c_comb.add_edges_from((p, f&#39;{ff}_d&#39;) for p in c_comb.predecessors(ff))
        c_comb.add_edge(c.nodes[ff][&#39;clk&#39;], f&#39;{ff}_clk&#39;)
        c_comb.remove_node(ff)

    return c_comb


def gen_lat_model():
    lm = nx.DiGraph()
    # inputs
    lm.add_node(&#39;si&#39;, gate=&#39;buf&#39;, output=False)
    lm.add_node(&#39;d&#39;, gate=&#39;buf&#39;, output=False)
    lm.add_node(&#39;clk&#39;, gate=&#39;buf&#39;, output=False)
    lm.add_node(&#39;rst&#39;, gate=&#39;buf&#39;, output=False)
    lm.add_node(&#39;mux_out&#39;, gate=&#39;or&#39;, output=False)
    lm.add_node(&#39;mux_a0&#39;, gate=&#39;and&#39;, output=False)
    lm.add_node(&#39;mux_a1&#39;, gate=&#39;and&#39;, output=False)
    lm.add_node(&#39;clk_b&#39;, gate=&#39;not&#39;, output=False)

    # outputs
    lm.add_node(&#39;q&#39;, gate=&#39;and&#39;, output=False)
    lm.add_node(&#39;so&#39;, gate=&#39;buf&#39;, output=False)

    # cons
    lm.add_edge(&#39;q&#39;, &#39;so&#39;)
    lm.add_edge(&#39;rst&#39;, &#39;q&#39;)
    lm.add_edge(&#39;mux_out&#39;, &#39;q&#39;)
    lm.add_edge(&#39;mux_out&#39;, &#39;q&#39;)
    lm.add_edge(&#39;mux_a0&#39;, &#39;mux_out&#39;)
    lm.add_edge(&#39;mux_a1&#39;, &#39;mux_out&#39;)
    lm.add_edge(&#39;clk&#39;, &#39;clk_b&#39;)
    lm.add_edge(&#39;clk_b&#39;, &#39;mux_a0&#39;)
    lm.add_edge(&#39;clk&#39;, &#39;mux_a1&#39;)
    lm.add_edge(&#39;d&#39;, &#39;mux_a0&#39;)
    lm.add_edge(&#39;si&#39;, &#39;mux_a1&#39;)

    return lm


def gen_ff_model():
    fm = nx.DiGraph()
    # inputs
    fm.add_node(&#39;si&#39;, gate=&#39;buf&#39;, output=False)
    fm.add_node(&#39;d&#39;, gate=&#39;buf&#39;, output=False)
    fm.add_node(&#39;clk&#39;, gate=&#39;buf&#39;, output=False)
    fm.add_node(&#39;mux_a0&#39;, gate=&#39;and&#39;, output=False)
    fm.add_node(&#39;mux_a1&#39;, gate=&#39;and&#39;, output=False)
    fm.add_node(&#39;clk_b&#39;, gate=&#39;not&#39;, output=False)

    # outputs
    fm.add_node(&#39;q&#39;, gate=&#39;and&#39;, output=False)
    fm.add_node(&#39;so&#39;, gate=&#39;or&#39;, output=False)

    # cons
    fm.add_edge(&#39;si&#39;, &#39;q&#39;)
    fm.add_edge(&#39;mux_a0&#39;, &#39;so&#39;)
    fm.add_edge(&#39;mux_a1&#39;, &#39;so&#39;)
    fm.add_edge(&#39;clk&#39;, &#39;clk_b&#39;)
    fm.add_edge(&#39;clk_b&#39;, &#39;mux_a0&#39;)
    fm.add_edge(&#39;clk&#39;, &#39;mux_a1&#39;)
    fm.add_edge(&#39;d&#39;, &#39;mux_a0&#39;)
    fm.add_edge(&#39;si&#39;, &#39;mux_a1&#39;)

    return fm


def unroll(c, cycles):
    &#34;&#34;&#34;
    Creates combinational unrolling of the circuit.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    cycles : int
            Number of cycles to unroll

    Returns
    -------
    Circuit
            Unrolled circuit.

    &#34;&#34;&#34;
    u = nx.DiGraph()
    c_comb = comb(c)
    for i in range(cycles):
        c_comb_i = nx.relabel_nodes(c_comb, {n: f&#39;{n}_{i}&#39; for n in c_comb})
        u.extend(c_comb_i)
        if i == 0:
            # convert si to inputs
            for n in c:
                if c.nodes[n][&#39;gate&#39;] in [&#39;lat&#39;, &#39;dff&#39;]:
                    u.nodes[f&#39;{n}_si_{i}&#39;][&#39;gate&#39;] = &#39;input&#39;

        else:
            # connect prev si
            for n in c:
                if c.nodes[n][&#39;gate&#39;] in [&#39;lat&#39;, &#39;dff&#39;]:
                    u.add_edge(f&#39;{n}_si_{i-1}&#39;, f&#39;{n}_si_{i}&#39;)
        for n in u:
            if &#39;gate&#39; not in u.nodes[n]:
                print(n)

    return u


def sensitivity(c, n):
    &#34;&#34;&#34;
    Creates a circuit to compute sensitivity.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    n : str
            Node to compute sensitivity at.

    Returns
    -------
    Circuit
            Sensitivity circuit.

    &#34;&#34;&#34;

    # get fanin cone of node
    if n in c.startpoints():
        print(f&#39;{n} is in startpoints&#39;)
        return None

    fiNodes = c.transitive_fanin(n) | set([n])
    startpoints = c.startpoints(n)
    subCircuit = Circuit(c.graph.subgraph(fiNodes).copy())

    # convert outputs to buffers
    for o in subCircuit.outputs():
        subCircuit.graph.nodes[o][&#39;type&#39;] = &#39;buf&#39;

    # convert startpoints to inputs
    for s in subCircuit.startpoints():
        subCircuit.graph.nodes[s][&#39;type&#39;] = &#39;input&#39;
        subCircuit.graph.remove_edges_from(
            (p, s) for p in list(subCircuit.graph.predecessors(s)))

    # create sensitivity circuit and add first copy of subcircuit
    sensitivityCircuit = Circuit()
    sensitivityCircuit.extend(subCircuit)

    # stamp out a copies of the circuit with s inverted
    for s in startpoints:
        mapping = {
            g: f&#39;sen_{s}_{g}&#39; for g in subCircuit
            if g not in startpoints-set([s])}
        relabeledSubCircuit = subCircuit.relabel(mapping)
        sensitivityCircuit.extend(relabeledSubCircuit)

        # connect inverted input
        sensitivityCircuit.graph.nodes[f&#39;sen_{s}_{s}&#39;][&#39;type&#39;] = &#39;not&#39;
        sensitivityCircuit.graph.add_edge(s, f&#39;sen_{s}_{s}&#39;)

        # compare to first copy
        sensitivityCircuit.add(
            f&#39;difference_{s}&#39;, &#39;xor&#39;, fanin=[n, f&#39;sen_{s}_{n}&#39;])
        sensitivityCircuit.add(
            f&#39;difference_{s}&#39;, &#39;output&#39;, fanin=f&#39;difference_{s}&#39;)

    return sensitivityCircuit


def sensitize(c, n):
    &#34;&#34;&#34;
    Creates a circuit to sensitize a node to an endpoint.

    Parameters
    ----------
    c : Circuit
            Input circuit.
    n : str
            Node to sensitize.

    Returns
    -------
    Circuit
            Output circuit.

    &#34;&#34;&#34;
    # get fanin/out cone of node
    nodes = c.transitive_fanin(n) | c.transitive_fanout(n) | set([n])
    subCircuit = Circuit(c.graph.subgraph(nodes).copy())

    # create miter
    m = miter(subCircuit)

    # cut and invert n in one side of miter
    m.graph.nodes[f&#39;c1_{n}&#39;][&#39;type&#39;] = &#39;not&#39;
    m.graph.remove_edges_from((f, f&#39;c1_{n}&#39;) for f in m.fanin(f&#39;c1_{n}&#39;))
    m.graph.add_edge(f&#39;c0_{n}&#39;, f&#39;c1_{n}&#39;)

    return m


def mphf(w=30, n=800):
    &#34;&#34;&#34;
    Creates a SAT-hard circuit based on the structure of minimum perfect hash
    functions.

    Parameters
    ----------
    w : int
            Input width.
    n : int
            Number of constraints.

    Returns
    -------
    Circuit
            Output circuit.

    &#34;&#34;&#34;
    o = max(1, math.ceil(math.log2(w)))
    c = Circuit()

    # add inputs
    inputs = [c.add(f&#39;in_{i}&#39;, &#39;input&#39;) for i in range(w)]

    # add constraints
    ors = []
    for ni in range(n):
        xors = [c.add(f&#39;xor_{ni}_{oi}&#39;, &#39;xor&#39;, fanin=sample(inputs, 2))
                for oi in range(o)]
        ors.append(c.add(f&#39;or_{ni}&#39;, &#39;or&#39;, fanin=xors))
    c.add(&#39;sat&#39;, &#39;and&#39;, fanin=ors)
    c.add(&#39;sat&#39;, &#39;output&#39;, fanin=&#39;sat&#39;)

    return c</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="circuitgraph.transform.comb"><code class="name flex">
<span>def <span class="ident">comb</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates combinational version of the circuit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Sequential circuit to make combinational.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Combinational circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comb(c):
    &#34;&#34;&#34;
    Creates combinational version of the circuit.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to make combinational.

    Returns
    -------
    Circuit
            Combinational circuit.

    &#34;&#34;&#34;
    c_comb = c.copy()
    lat_model = gen_lat_model()
    ff_model = gen_ff_model()

    for lat in c.lats():
        relabeled_model = nx.relabel_nodes(
            lat_model, {n: f&#39;{lat}_{n}&#39; for n in lat_model})
        c_comb.extend(relabeled_model)
        c_comb.add_edges_from((f&#39;{lat}_q&#39;, s) for s in c_comb.successors(lat))
        c_comb.add_edges_from((p, f&#39;{lat}_d&#39;)
                              for p in c_comb.predecessors(lat))
        c_comb.add_edge(c.nodes[lat][&#39;clk&#39;], f&#39;{lat}_clk&#39;)
        c_comb.add_edge(c.nodes[lat][&#39;rst&#39;], f&#39;{lat}_rst&#39;)
        c_comb.remove_node(lat)

    for ff in c.ffs():
        relabeled_model = nx.relabel_nodes(
            ff_model, {n: f&#39;{ff}_{n}&#39; for n in ff_model})
        c_comb.extend(relabeled_model)
        c_comb.add_edges_from((f&#39;{ff}_q&#39;, s) for s in c_comb.successors(ff))
        c_comb.add_edges_from((p, f&#39;{ff}_d&#39;) for p in c_comb.predecessors(ff))
        c_comb.add_edge(c.nodes[ff][&#39;clk&#39;], f&#39;{ff}_clk&#39;)
        c_comb.remove_node(ff)

    return c_comb</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.gen_ff_model"><code class="name flex">
<span>def <span class="ident">gen_ff_model</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_ff_model():
    fm = nx.DiGraph()
    # inputs
    fm.add_node(&#39;si&#39;, gate=&#39;buf&#39;, output=False)
    fm.add_node(&#39;d&#39;, gate=&#39;buf&#39;, output=False)
    fm.add_node(&#39;clk&#39;, gate=&#39;buf&#39;, output=False)
    fm.add_node(&#39;mux_a0&#39;, gate=&#39;and&#39;, output=False)
    fm.add_node(&#39;mux_a1&#39;, gate=&#39;and&#39;, output=False)
    fm.add_node(&#39;clk_b&#39;, gate=&#39;not&#39;, output=False)

    # outputs
    fm.add_node(&#39;q&#39;, gate=&#39;and&#39;, output=False)
    fm.add_node(&#39;so&#39;, gate=&#39;or&#39;, output=False)

    # cons
    fm.add_edge(&#39;si&#39;, &#39;q&#39;)
    fm.add_edge(&#39;mux_a0&#39;, &#39;so&#39;)
    fm.add_edge(&#39;mux_a1&#39;, &#39;so&#39;)
    fm.add_edge(&#39;clk&#39;, &#39;clk_b&#39;)
    fm.add_edge(&#39;clk_b&#39;, &#39;mux_a0&#39;)
    fm.add_edge(&#39;clk&#39;, &#39;mux_a1&#39;)
    fm.add_edge(&#39;d&#39;, &#39;mux_a0&#39;)
    fm.add_edge(&#39;si&#39;, &#39;mux_a1&#39;)

    return fm</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.gen_lat_model"><code class="name flex">
<span>def <span class="ident">gen_lat_model</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gen_lat_model():
    lm = nx.DiGraph()
    # inputs
    lm.add_node(&#39;si&#39;, gate=&#39;buf&#39;, output=False)
    lm.add_node(&#39;d&#39;, gate=&#39;buf&#39;, output=False)
    lm.add_node(&#39;clk&#39;, gate=&#39;buf&#39;, output=False)
    lm.add_node(&#39;rst&#39;, gate=&#39;buf&#39;, output=False)
    lm.add_node(&#39;mux_out&#39;, gate=&#39;or&#39;, output=False)
    lm.add_node(&#39;mux_a0&#39;, gate=&#39;and&#39;, output=False)
    lm.add_node(&#39;mux_a1&#39;, gate=&#39;and&#39;, output=False)
    lm.add_node(&#39;clk_b&#39;, gate=&#39;not&#39;, output=False)

    # outputs
    lm.add_node(&#39;q&#39;, gate=&#39;and&#39;, output=False)
    lm.add_node(&#39;so&#39;, gate=&#39;buf&#39;, output=False)

    # cons
    lm.add_edge(&#39;q&#39;, &#39;so&#39;)
    lm.add_edge(&#39;rst&#39;, &#39;q&#39;)
    lm.add_edge(&#39;mux_out&#39;, &#39;q&#39;)
    lm.add_edge(&#39;mux_out&#39;, &#39;q&#39;)
    lm.add_edge(&#39;mux_a0&#39;, &#39;mux_out&#39;)
    lm.add_edge(&#39;mux_a1&#39;, &#39;mux_out&#39;)
    lm.add_edge(&#39;clk&#39;, &#39;clk_b&#39;)
    lm.add_edge(&#39;clk_b&#39;, &#39;mux_a0&#39;)
    lm.add_edge(&#39;clk&#39;, &#39;mux_a1&#39;)
    lm.add_edge(&#39;d&#39;, &#39;mux_a0&#39;)
    lm.add_edge(&#39;si&#39;, &#39;mux_a1&#39;)

    return lm</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.miter"><code class="name flex">
<span>def <span class="ident">miter</span></span>(<span>c0, c1=None, startpoints=None, endpoints=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a miter circuit</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c0</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>First circuit.</dd>
<dt><strong><code>c1</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Optional second circuit, if None c0 is mitered with itself.</dd>
<dt><strong><code>startpoints</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>Nodes to be tied together, must exist in both circuits.</dd>
<dt><strong><code>endpoints</code></strong> :&ensp;<code>iterable</code> of <code>str</code></dt>
<dd>Nodes to be compared, must exist in both circuits.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Miter circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def miter(c0, c1=None, startpoints=None, endpoints=None):
    &#34;&#34;&#34;
    Creates a miter circuit

    Parameters
    ----------
    c0 : Circuit
            First circuit.
    c1 : Circuit
            Optional second circuit, if None c0 is mitered with itself.
    startpoints : iterable of str
            Nodes to be tied together, must exist in both circuits.
    endpoints : iterable of str
            Nodes to be compared, must exist in both circuits.

    Returns
    -------
    Circuit
            Miter circuit.

    &#34;&#34;&#34;
    if not c1:
        c1 = c0
    if not startpoints:
        startpoints = c0.startpoints() &amp; c1.startpoints()
    if not endpoints:
        endpoints = c0.endpoints() &amp; c1.endpoints()

    # create miter, relabel to avoid overlap except for common startpoints
    m = c0.relabel({n: f&#39;c0_{n}&#39; for n in c0.nodes()-startpoints})
    m.extend(c1.relabel({n: f&#39;c1_{n}&#39; for n in c1.nodes()-startpoints}))

    # compare outputs
    m.add(&#39;sat&#39;, &#39;or&#39;)
    for o in endpoints:
        m.add(f&#39;miter_{o}&#39;, &#39;xor&#39;, fanin=[
              f&#39;c0_{o}&#39;, f&#39;c1_{o}&#39;], fanout=[&#39;sat&#39;])

    return m</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.mphf"><code class="name flex">
<span>def <span class="ident">mphf</span></span>(<span>w=30, n=800)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a SAT-hard circuit based on the structure of minimum perfect hash
functions.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>w</code></strong> :&ensp;<code>int</code></dt>
<dd>Input width.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of constraints.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Output circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mphf(w=30, n=800):
    &#34;&#34;&#34;
    Creates a SAT-hard circuit based on the structure of minimum perfect hash
    functions.

    Parameters
    ----------
    w : int
            Input width.
    n : int
            Number of constraints.

    Returns
    -------
    Circuit
            Output circuit.

    &#34;&#34;&#34;
    o = max(1, math.ceil(math.log2(w)))
    c = Circuit()

    # add inputs
    inputs = [c.add(f&#39;in_{i}&#39;, &#39;input&#39;) for i in range(w)]

    # add constraints
    ors = []
    for ni in range(n):
        xors = [c.add(f&#39;xor_{ni}_{oi}&#39;, &#39;xor&#39;, fanin=sample(inputs, 2))
                for oi in range(o)]
        ors.append(c.add(f&#39;or_{ni}&#39;, &#39;or&#39;, fanin=xors))
    c.add(&#39;sat&#39;, &#39;and&#39;, fanin=ors)
    c.add(&#39;sat&#39;, &#39;output&#39;, fanin=&#39;sat&#39;)

    return c</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.sensitivity"><code class="name flex">
<span>def <span class="ident">sensitivity</span></span>(<span>c, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a circuit to compute sensitivity.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Sequential circuit to unroll.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>str</code></dt>
<dd>Node to compute sensitivity at.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Sensitivity circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sensitivity(c, n):
    &#34;&#34;&#34;
    Creates a circuit to compute sensitivity.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    n : str
            Node to compute sensitivity at.

    Returns
    -------
    Circuit
            Sensitivity circuit.

    &#34;&#34;&#34;

    # get fanin cone of node
    if n in c.startpoints():
        print(f&#39;{n} is in startpoints&#39;)
        return None

    fiNodes = c.transitive_fanin(n) | set([n])
    startpoints = c.startpoints(n)
    subCircuit = Circuit(c.graph.subgraph(fiNodes).copy())

    # convert outputs to buffers
    for o in subCircuit.outputs():
        subCircuit.graph.nodes[o][&#39;type&#39;] = &#39;buf&#39;

    # convert startpoints to inputs
    for s in subCircuit.startpoints():
        subCircuit.graph.nodes[s][&#39;type&#39;] = &#39;input&#39;
        subCircuit.graph.remove_edges_from(
            (p, s) for p in list(subCircuit.graph.predecessors(s)))

    # create sensitivity circuit and add first copy of subcircuit
    sensitivityCircuit = Circuit()
    sensitivityCircuit.extend(subCircuit)

    # stamp out a copies of the circuit with s inverted
    for s in startpoints:
        mapping = {
            g: f&#39;sen_{s}_{g}&#39; for g in subCircuit
            if g not in startpoints-set([s])}
        relabeledSubCircuit = subCircuit.relabel(mapping)
        sensitivityCircuit.extend(relabeledSubCircuit)

        # connect inverted input
        sensitivityCircuit.graph.nodes[f&#39;sen_{s}_{s}&#39;][&#39;type&#39;] = &#39;not&#39;
        sensitivityCircuit.graph.add_edge(s, f&#39;sen_{s}_{s}&#39;)

        # compare to first copy
        sensitivityCircuit.add(
            f&#39;difference_{s}&#39;, &#39;xor&#39;, fanin=[n, f&#39;sen_{s}_{n}&#39;])
        sensitivityCircuit.add(
            f&#39;difference_{s}&#39;, &#39;output&#39;, fanin=f&#39;difference_{s}&#39;)

    return sensitivityCircuit</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.sensitize"><code class="name flex">
<span>def <span class="ident">sensitize</span></span>(<span>c, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a circuit to sensitize a node to an endpoint.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Input circuit.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>str</code></dt>
<dd>Node to sensitize.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Output circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sensitize(c, n):
    &#34;&#34;&#34;
    Creates a circuit to sensitize a node to an endpoint.

    Parameters
    ----------
    c : Circuit
            Input circuit.
    n : str
            Node to sensitize.

    Returns
    -------
    Circuit
            Output circuit.

    &#34;&#34;&#34;
    # get fanin/out cone of node
    nodes = c.transitive_fanin(n) | c.transitive_fanout(n) | set([n])
    subCircuit = Circuit(c.graph.subgraph(nodes).copy())

    # create miter
    m = miter(subCircuit)

    # cut and invert n in one side of miter
    m.graph.nodes[f&#39;c1_{n}&#39;][&#39;type&#39;] = &#39;not&#39;
    m.graph.remove_edges_from((f, f&#39;c1_{n}&#39;) for f in m.fanin(f&#39;c1_{n}&#39;))
    m.graph.add_edge(f&#39;c0_{n}&#39;, f&#39;c1_{n}&#39;)

    return m</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.syn"><code class="name flex">
<span>def <span class="ident">syn</span></span>(<span>c, engine='Genus', printOutput=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Synthesizes the circuit using Genus.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Circuit to synthesize.</dd>
<dt><strong><code>engine</code></strong> :&ensp;<code>string</code></dt>
<dd>Synthesis tool to use ('Genus' or 'Yosys')</dd>
<dt><strong><code>printOutput</code></strong> :&ensp;<code>bool</code></dt>
<dd>Option to print synthesis log</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Synthesized circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def syn(c, engine=&#39;Genus&#39;, printOutput=False):
    &#34;&#34;&#34;
    Synthesizes the circuit using Genus.

    Parameters
    ----------
    c : Circuit
            Circuit to synthesize.
    engine : string
            Synthesis tool to use (&#39;Genus&#39; or &#39;Yosys&#39;)
    printOutput : bool
            Option to print synthesis log

    Returns
    -------
    Circuit
            Synthesized circuit.
    &#34;&#34;&#34;
    verilog = circuit_to_verilog(c)

    # probably should write output to the tmp file
    with NamedTemporaryFile() as tmp:
        if engine == &#39;Genus&#39;:
            cmd = [&#39;genus&#39;, &#39;-no_gui&#39;, &#39;-execute&#39;,
                   &#39;set_db / .library &#39;
                   f&#34;{os.environ[&#39;CIRCUITGRAPH_GENUS_LIBRARY_PATH&#39;]};\n&#34;
                   f&#39;read_hdl -sv {tmp.name};\n&#39;
                   &#39;elaborate;\n&#39;
                   &#39;set_db syn_generic_effort high;\n&#39;
                   &#39;syn_generic;\n&#39;
                   &#39;syn_map;\n&#39;
                   &#39;syn_opt;\n&#39;
                   &#39;write_hdl -generic;\n&#39;
                   &#39;exit;&#39;]
        else:
            print(&#39;not implemented&#39;)
        tmp.write(bytes(verilog, &#39;ascii&#39;))
        tmp.flush()

        process = Popen(cmd, stdout=PIPE, stderr=PIPE,
                        universal_newlines=True)
        output = &#39;&#39;
        while True:
            line = process.stdout.readline()
            if line == &#39;&#39; and process.poll() is not None:
                break
            if line:
                if printOutput:
                    print(line.strip())
                output += line

    return verilog_to_circuit(output, c.name)</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.ternary"><code class="name flex">
<span>def <span class="ident">ternary</span></span>(<span>c)</span>
</code></dt>
<dd>
<div class="desc"><p>Encodes the circuit with ternary values</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Circuit to encode.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Encoded circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ternary(c):
    &#34;&#34;&#34;
    Encodes the circuit with ternary values

    Parameters
    ----------
    c : Circuit
            Circuit to encode.

    Returns
    -------
    Circuit
            Encoded circuit.

    &#34;&#34;&#34;
    t = c.copy()

    # add dual nodes
    for n in c:
        if c.type(n) in [&#39;and&#39;, &#39;nand&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;and&#39;, output=c.nodes[n][&#39;output&#39;])
            t.add_node(f&#39;{n}_x_in_fi&#39;, gate=&#39;or&#39;, output=False)
            t.add_node(f&#39;{n}_0_not_in_fi&#39;, gate=&#39;nor&#39;, output=False)
            t.add_edges_from([(f&#39;{n}_x_in_fi&#39;, f&#39;{n}_x&#39;),
                              (f&#39;{n}_0_not_in_fi&#39;, f&#39;{n}_x&#39;)])
            t.add_edges_from((f&#39;{p}_x&#39;, f&#39;{n}_x_in_fi&#39;)
                             for p in c.predecessors(n))
            for p in c.predecessors(n):
                t.add_node(f&#39;{p}_is_0&#39;, gate=&#39;nor&#39;, output=False)
                t.add_edge(f&#39;{p}_is_0&#39;, f&#39;{n}_0_not_in_fi&#39;)
                t.add_edge(f&#39;{p}_x&#39;, f&#39;{p}_is_0&#39;)
                t.add_edge(p, f&#39;{p}_is_0&#39;)

        elif c.type(n) in [&#39;or&#39;, &#39;nor&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;and&#39;, output=c.nodes[n][&#39;output&#39;])
            t.add_node(f&#39;{n}_x_in_fi&#39;, gate=&#39;or&#39;, output=False)
            t.add_node(f&#39;{n}_1_not_in_fi&#39;, gate=&#39;nor&#39;, output=False)
            t.add_edges_from([(f&#39;{n}_x_in_fi&#39;, f&#39;{n}_x&#39;),
                              (f&#39;{n}_1_not_in_fi&#39;, f&#39;{n}_x&#39;)])
            t.add_edges_from((f&#39;{p}_x&#39;, f&#39;{n}_x_in_fi&#39;)
                             for p in c.predecessors(n))
            for p in c.predecessors(n):
                t.add_node(f&#39;{p}_is_1&#39;, gate=&#39;and&#39;, output=False)
                t.add_edge(f&#39;{p}_is_1&#39;, f&#39;{n}_1_not_in_fi&#39;)
                t.add_node(f&#39;{p}_not_x&#39;, gate=&#39;not&#39;, output=False)
                t.add_edge(f&#39;{p}_x&#39;, f&#39;{p}_not_x&#39;)
                t.add_edge(f&#39;{p}_not_x&#39;, f&#39;{p}_is_1&#39;)
                t.add_edge(p, f&#39;{p}_is_1&#39;)

        elif c.type(n) in [&#39;buf&#39;, &#39;not&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;buf&#39;, output=c.nodes[n][&#39;output&#39;])
            p = list(c.predecessors(n))[0]
            t.add_edge(f&#39;{p}_x&#39;, f&#39;{n}_x&#39;)

        elif c.type(n) in [&#39;xor&#39;, &#39;xnor&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;or&#39;, output=c.nodes[n][&#39;output&#39;])
            t.add_edges_from((f&#39;{p}_x&#39;, f&#39;{n}_x&#39;) for p in c.predecessors(n))

        elif c.type(n) in [&#39;0&#39;, &#39;1&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;0&#39;, output=c.nodes[n][&#39;output&#39;])

        elif c.type(n) in [&#39;input&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;input&#39;, output=c.nodes[n][&#39;output&#39;])

        elif c.type(n) in [&#39;dff&#39;]:
            t.add_node(f&#39;{n}_x&#39;, gate=&#39;dff&#39;,
                       output=c.nodes[n][&#39;output&#39;], clk=c.nodes[n][&#39;clk&#39;])
            p = list(c.predecessors(n))[0]
            t.add_edge(f&#39;{p}_x&#39;, f&#39;{n}_x&#39;)

        elif c.type(n) in [&#39;lat&#39;]:
            t.add_node(
                f&#39;{n}_x&#39;, gate=&#39;lat&#39;, output=c.nodes[n][&#39;output&#39;],
                clk=c.nodes[n][&#39;clk&#39;], rst=c.nodes[n][&#39;rst&#39;])
            p = list(c.predecessors(n))[0]
            t.add_edge(f&#39;{p}_x&#39;, f&#39;{n}_x&#39;)

        else:
            print(f&#34;unknown gate type: {c.nodes[n][&#39;type&#39;]}&#34;)
            code.interact(local=dict(globals(), **locals()))

    for n in t:
        if &#39;type&#39; not in t.nodes[n]:
            print(f&#34;empty gate type: {n}&#34;)
            code.interact(local=dict(globals(), **locals()))

    return t</code></pre>
</details>
</dd>
<dt id="circuitgraph.transform.unroll"><code class="name flex">
<span>def <span class="ident">unroll</span></span>(<span>c, cycles)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates combinational unrolling of the circuit.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>Circuit</code></dt>
<dd>Sequential circuit to unroll.</dd>
<dt><strong><code>cycles</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of cycles to unroll</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Circuit</code></dt>
<dd>Unrolled circuit.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unroll(c, cycles):
    &#34;&#34;&#34;
    Creates combinational unrolling of the circuit.

    Parameters
    ----------
    c : Circuit
            Sequential circuit to unroll.
    cycles : int
            Number of cycles to unroll

    Returns
    -------
    Circuit
            Unrolled circuit.

    &#34;&#34;&#34;
    u = nx.DiGraph()
    c_comb = comb(c)
    for i in range(cycles):
        c_comb_i = nx.relabel_nodes(c_comb, {n: f&#39;{n}_{i}&#39; for n in c_comb})
        u.extend(c_comb_i)
        if i == 0:
            # convert si to inputs
            for n in c:
                if c.nodes[n][&#39;gate&#39;] in [&#39;lat&#39;, &#39;dff&#39;]:
                    u.nodes[f&#39;{n}_si_{i}&#39;][&#39;gate&#39;] = &#39;input&#39;

        else:
            # connect prev si
            for n in c:
                if c.nodes[n][&#39;gate&#39;] in [&#39;lat&#39;, &#39;dff&#39;]:
                    u.add_edge(f&#39;{n}_si_{i-1}&#39;, f&#39;{n}_si_{i}&#39;)
        for n in u:
            if &#39;gate&#39; not in u.nodes[n]:
                print(n)

    return u</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<header>
<img src="circuitgraph.png" alt="">
<script async defer src="https://buttons.github.io/buttons.js"></script>
<a class="github-button" href="https://github.com/circuitgraph/circuigraph" aria-label="Star circuitgraph/circuigraph on GitHub">Star</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="circuitgraph" href="index.html">circuitgraph</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="circuitgraph.transform.comb" href="#circuitgraph.transform.comb">comb</a></code></li>
<li><code><a title="circuitgraph.transform.gen_ff_model" href="#circuitgraph.transform.gen_ff_model">gen_ff_model</a></code></li>
<li><code><a title="circuitgraph.transform.gen_lat_model" href="#circuitgraph.transform.gen_lat_model">gen_lat_model</a></code></li>
<li><code><a title="circuitgraph.transform.miter" href="#circuitgraph.transform.miter">miter</a></code></li>
<li><code><a title="circuitgraph.transform.mphf" href="#circuitgraph.transform.mphf">mphf</a></code></li>
<li><code><a title="circuitgraph.transform.sensitivity" href="#circuitgraph.transform.sensitivity">sensitivity</a></code></li>
<li><code><a title="circuitgraph.transform.sensitize" href="#circuitgraph.transform.sensitize">sensitize</a></code></li>
<li><code><a title="circuitgraph.transform.syn" href="#circuitgraph.transform.syn">syn</a></code></li>
<li><code><a title="circuitgraph.transform.ternary" href="#circuitgraph.transform.ternary">ternary</a></code></li>
<li><code><a title="circuitgraph.transform.unroll" href="#circuitgraph.transform.unroll">unroll</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.3</a>.</p>
</footer>
</body>
</html>